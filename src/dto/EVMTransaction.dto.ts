//////////////////////////////////////////////////////////////////////////////////////////
/////// THIS CODE IS AUTOGENERATED. DO NOT CHANGE!!!                             /////////
//////////////////////////////////////////////////////////////////////////////////////////
import { ApiProperty, OmitType } from "@nestjs/swagger";
import { Type } from "class-transformer";
import {
    Validate,
    IsBoolean,
    ValidationArguments,
    ValidatorConstraint,
    ValidatorConstraintInterface,
    IsDefined,
    IsNotEmptyObject,
    IsObject,
    ValidateNested,
} from "class-validator";

///////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// CUSTOM VALIDATORS ////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Validator constraint if the given value is a number or 0x-prefixed hexadecimal string.
 */
@ValidatorConstraint({ name: "unsigned-int", async: false })
class IsUnsignedIntLike implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is a string of decimal unsigned number or 0x-prefixed hexadecimal string.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, _args: ValidationArguments) {
        return typeof text === "string" && (/^0x[0-9a-fA-F]+$/i.test(text) || /^[0-9]+$/i.test(text));
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(_args: ValidationArguments) {
        return "($property) value ($value) is not a decimal number in string or 0x-prefixed hexadecimal string";
    }
}

/**
 * Validator constraint if the given value is a number or 0x-prefixed hexadecimal string.
 */
@ValidatorConstraint({ name: "signed-int", async: false })
class IsSignedIntLike implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is a number or 0x-prefixed hexadecimal string.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, _args: ValidationArguments) {
        return typeof text === "string" && (/^-?0x[0-9a-fA-F]+$/i.test(text) || /^-?[0-9]+$/i.test(text));
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(_args: ValidationArguments) {
        return "($property) value ($value) is not a signed decimal integer in string or signed 0x-prefixed hexadecimal string";
    }
}

/**
 * Validator constraint if the given value is a 0x-prefixed hexadecimal string representing 32 bytes.
 */
@ValidatorConstraint({ name: "hash-32", async: false })
class IsHash32 implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is a 0x-prefixed hexadecimal string representing 32 bytes.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, _args: ValidationArguments) {
        return typeof text === "string" && /^0x[0-9a-f]{64}$/i.test(text);
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(_args: ValidationArguments) {
        return "($property) value ($value) is not 0x-prefixed hexadecimal string representing 32 bytes";
    }
}

/**
 * Validator constraint if the given value is a 0x-prefixed hexadecimal string
 */
@ValidatorConstraint({ name: "hash-0x", async: false })
class Is0xHex implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is a 0x-prefixed hexadecimal string
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, _args: ValidationArguments) {
        return typeof text === "string" && /^0x[0-9a-f]+$/i.test(text);
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(_args: ValidationArguments) {
        return "($property) value ($value) is not 0x-prefixed hexadecimal string";
    }
}

/**
 * Validator constraint if the given value is an EVM address, hence 0x-prefixed hexadecimal string representing 20 bytes.
 */
@ValidatorConstraint({ name: "evm-address", async: false })
class IsEVMAddress implements ValidatorConstraintInterface {
    /**
     * Validates if the given value is an EVM address, hence 0x-prefixed hexadecimal string representing 20 bytes.
     * @param text
     * @param args
     * @returns
     */
    validate(text: any, _args: ValidationArguments) {
        return typeof text === "string" && /^0x[0-9a-f]{40}$/i.test(text);
    }

    /**
     * Returns the default error message template.
     * @param args
     * @returns
     */
    defaultMessage(_args: ValidationArguments) {
        return "($property) value ($value) is not 0x-prefixed hexadecimal string representing 20 bytes (EVM address)";
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// DTOs /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

export class EVMTransaction_Event {
    constructor(params: Required<EVMTransaction_Event>) {
        Object.assign(this, params);
    }

    /**
     * The consecutive number of the event in block.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `The consecutive number of the event in block.`, example: "123" })
    logIndex: string;

    /**
     * The address of the contract that emitted the event.
     */
    @Validate(IsEVMAddress)
    @ApiProperty({ description: `The address of the contract that emitted the event.`, example: "0x5d4BEB38B6b71aaF6e30D0F9FeB6e21a7Ac40b3a" })
    emitterAddress: string;

    /**
     * An array of up to 4 32-byte strings of indexed log arguments. The first string is the signature of the event.
     */
    @Validate(IsHash32, { each: true })
    @ApiProperty({
        description: `An array of up to 4 32-byte strings of indexed log arguments. The first string is the signature of the event.`,
        example: ["0x0000000000000000000000000000000000000000000000000000000000000000"],
    })
    topics: string[];

    /**
     * Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.
     */
    @Validate(Is0xHex)
    @ApiProperty({ description: `Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.`, example: "0x1234abcd" })
    data: string;

    /**
     * It is true if log was removed due to a chain reorganization and false if it is a valid log.
     */
    @IsBoolean()
    @ApiProperty({ description: `It is true if log was removed due to a chain reorganization and false if it is a valid log.`, example: true })
    removed: boolean;
}
export class EVMTransaction_ResponseBody {
    constructor(params: Required<EVMTransaction_ResponseBody>) {
        Object.assign(this, params);
    }

    /**
     * Number of the block in which the transaction is included.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Number of the block in which the transaction is included.`, example: "123" })
    blockNumber: string;

    /**
     * Timestamp of the block in which the transaction is included.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Timestamp of the block in which the transaction is included.`, example: "123" })
    timestamp: string;

    /**
     * The address (from) that signed the transaction.
     */
    @Validate(IsEVMAddress)
    @ApiProperty({ description: `The address (from) that signed the transaction.`, example: "0x5d4BEB38B6b71aaF6e30D0F9FeB6e21a7Ac40b3a" })
    sourceAddress: string;

    /**
     * Indicate whether it is a contract creation transaction.
     */
    @IsBoolean()
    @ApiProperty({ description: `Indicate whether it is a contract creation transaction.`, example: true })
    isDeployment: boolean;

    /**
     * The address (to) of the receiver of the initial transaction. Zero address if `isDeployment` is true.
     */
    @Validate(IsEVMAddress)
    @ApiProperty({
        description: `The address (to) of the receiver of the initial transaction. Zero address if 'isDeployment' is true.`,
        example: "0x5d4BEB38B6b71aaF6e30D0F9FeB6e21a7Ac40b3a",
    })
    receivingAddress: string;

    /**
     * The value transferred by the initial transaction in wei.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `The value transferred by the initial transaction in wei.`, example: "123" })
    value: string;

    /**
     * If `provideInput`, this is the data send along with the initial transaction. Otherwise it is the default value `0x00`.
     */
    @Validate(Is0xHex)
    @ApiProperty({
        description: `If 'provideInput', this is the data send along with the initial transaction. Otherwise it is the default value '0x00'.`,
        example: "0x1234abcd",
    })
    input: string;

    /**
     * Status of the transaction 1 - success, 0 - failure.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `Status of the transaction 1 - success, 0 - failure.`, example: "123" })
    status: string;

    /**
     * If `listEvents` is true, an array of the requested events. Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.
     */
    @ValidateNested({ each: true })
    @Type(() => EVMTransaction_Event)
    @IsDefined({ each: true })
    @IsObject({ each: true })
    @ApiProperty({
        description: `If 'listEvents' is true, an array of the requested events. Sorted by the logIndex in the same order as 'logIndices'. Otherwise, an empty array.`,
    })
    events: EVMTransaction_Event[];
}
export class EVMTransaction_RequestBody {
    constructor(params: Required<EVMTransaction_RequestBody>) {
        Object.assign(this, params);
    }

    /**
     * Hash of the transaction(transactionHash).
     */
    @Validate(IsHash32)
    @ApiProperty({ description: `Hash of the transaction(transactionHash).`, example: "0x0000000000000000000000000000000000000000000000000000000000000000" })
    transactionHash: string;

    /**
     * The height at which a block is considered confirmed by the requestor.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `The height at which a block is considered confirmed by the requestor.`, example: "123" })
    requiredConfirmations: string;

    /**
     * If true, "input" field is included in the response.
     */
    @IsBoolean()
    @ApiProperty({ description: `If true, "input" field is included in the response.`, example: true })
    provideInput: boolean;

    /**
     * If true, events indicated by `logIndices` are included in the response. Otherwise, no events are included in the response.
     */
    @IsBoolean()
    @ApiProperty({
        description: `If true, events indicated by 'logIndices' are included in the response. Otherwise, no events are included in the response.`,
        example: true,
    })
    listEvents: boolean;

    /**
     * If listeEvents is false, this should be an empty list, otherwise, the request is rejected. If listEvemts is true this is the list of indices of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices. If empty, it indicates all events in order capped by 50.
     */
    @Validate(IsUnsignedIntLike, { each: true })
    @ApiProperty({
        description: `If listeEvents is false, this should be an empty list, otherwise, the request is rejected. If listEvemts is true this is the list of indices of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices. If empty, it indicates all events in order capped by 50.`,
        example: ["123"],
    })
    logIndices: string[];
}
export class EVMTransaction_Request {
    constructor(params: Required<EVMTransaction_Request>) {
        Object.assign(this, params);
    }

    /**
     * Attestation type id as defined for each attestation type on [this repo](https://gitlab.com/flarenetwork/state-connector-protocol/)
     */
    @Validate(IsHash32)
    @ApiProperty({
        description: `Attestation type id as defined for each attestation type on [this repo](https://gitlab.com/flarenetwork/state-connector-protocol/)`,
        example: "0x45564d5472616e73616374696f6e000000000000000000000000000000000000",
    })
    attestationType: string;

    /**
     * Id of the data source.
     */
    @Validate(IsHash32)
    @ApiProperty({ description: `Id of the data source.`, example: "0x4254430000000000000000000000000000000000000000000000000000000000" })
    sourceId: string;

    /**
     * `MessageIntegrityCode` that is derived from the expected response as defined [here](/specs/attestations/hash-MIC.md#message-integrity-code).
     */
    @Validate(IsHash32)
    @ApiProperty({
        description: `'MessageIntegrityCode' that is derived from the expected response as defined [here](/specs/attestations/hash-MIC.md#message-integrity-code).`,
        example: "0x0000000000000000000000000000000000000000000000000000000000000000",
    })
    messageIntegrityCode: string;

    /**
     * Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.
     */
    @ValidateNested()
    @Type(() => EVMTransaction_RequestBody)
    @IsDefined()
    @IsNotEmptyObject()
    @IsObject()
    @ApiProperty({ description: `Data defining the request. Type (struct) and interpretation is determined by the 'attestationType'.` })
    requestBody: EVMTransaction_RequestBody;
}
export class EVMTransaction_Response {
    constructor(params: Required<EVMTransaction_Response>) {
        Object.assign(this, params);
    }

    /**
     * Extracted from the request.
     */
    @Validate(IsHash32)
    @ApiProperty({ description: `Extracted from the request.`, example: "0x45564d5472616e73616374696f6e000000000000000000000000000000000000" })
    attestationType: string;

    /**
     * Extracted from the request.
     */
    @Validate(IsHash32)
    @ApiProperty({ description: `Extracted from the request.`, example: "0x4254430000000000000000000000000000000000000000000000000000000000" })
    sourceId: string;

    /**
     * The id of the state connector round in which the request was considered.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `The id of the state connector round in which the request was considered.`, example: "123" })
    votingRound: string;

    /**
     * The lowest timestamp used to generate the response.
     */
    @Validate(IsUnsignedIntLike)
    @ApiProperty({ description: `The lowest timestamp used to generate the response.`, example: "123" })
    lowestUsedTimestamp: string;

    /**
     * Extracted from the request.
     */
    @ValidateNested()
    @Type(() => EVMTransaction_RequestBody)
    @IsDefined()
    @IsNotEmptyObject()
    @IsObject()
    @ApiProperty({ description: `Extracted from the request.` })
    requestBody: EVMTransaction_RequestBody;

    /**
     * Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.
     */
    @ValidateNested()
    @Type(() => EVMTransaction_ResponseBody)
    @IsDefined()
    @IsNotEmptyObject()
    @IsObject()
    @ApiProperty({
        description: `Data defining the response. The verification rules for the construction of the response body and the type are defined per specific 'attestationType'.`,
    })
    responseBody: EVMTransaction_ResponseBody;
}
export class EVMTransaction_Proof {
    constructor(params: Required<EVMTransaction_Proof>) {
        Object.assign(this, params);
    }

    /**
     * Merkle proof corresponding to the attestation response.
     */
    @Validate(IsHash32, { each: true })
    @ApiProperty({
        description: `Merkle proof corresponding to the attestation response.`,
        example: ["0x0000000000000000000000000000000000000000000000000000000000000000"],
    })
    merkleProof: string[];

    /**
     * Attestation response.
     */
    @ValidateNested()
    @Type(() => EVMTransaction_Response)
    @IsDefined()
    @IsNotEmptyObject()
    @IsObject()
    @ApiProperty({ description: `Attestation response.` })
    data: EVMTransaction_Response;
}

export class EVMTransaction_RequestNoMic extends OmitType<EVMTransaction_Request, "messageIntegrityCode">(EVMTransaction_Request, [
    "messageIntegrityCode",
] as const) {}
